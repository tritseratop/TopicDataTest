// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file TypeTopics.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "TypeTopics.h"
#include "TypeTopicsTypeObject.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

namespace scada_ate
{
    namespace typetopics
    {
        size_t MaxSizeDataCollectionInt = 0;
        size_t MaxSizeDataCollectionFloat = 0;
        size_t MaxSizeDataCollectionDouble = 0;
        size_t MaxSizeDataCollectionChar = 0;

        size_t MaxSizeDDSDataExVectorInt = 0;
        size_t MaxSizeDDSDataExVectorFloat = 0;
        size_t MaxSizeDDSDataExVectorDouble = 0;
        size_t MaxSizeDDSDataExVectorChar = 0;

        size_t MaxSizeDDSAlarmVectorAlarm = 0;
        size_t MaxSizeDDSExVectorAlarms = 0;

        void SetMaxSizeDataCollectionInt(size_t size) { MaxSizeDataCollectionInt = size; };
        void SetMaxSizeDataCollectionFloat(size_t size) { MaxSizeDataCollectionFloat = size; };;
        void SetMaxSizeDataCollectionDouble(size_t size) { MaxSizeDataCollectionDouble = size; };;
        void SetMaxSizeDataCollectionChar(size_t size) { MaxSizeDataCollectionChar = size; };;

        size_t GetMaxSizeDataCollectionInt() { return MaxSizeDataCollectionInt; };
        size_t GetMaxSizeDataCollectionFloat() { return MaxSizeDataCollectionFloat; };
        size_t GetMaxSizeDataCollectionDouble() { return MaxSizeDataCollectionDouble; };
        size_t GetMaxSizeDataCollectionChar() { return MaxSizeDataCollectionChar; };

        void SetMaxSizeDDSDataExVectorInt(size_t size) { MaxSizeDDSDataExVectorInt = size; };
        void SetMaxSizeDDSDataExVectorFloat(size_t size) { MaxSizeDDSDataExVectorFloat = size; };
        void SetMaxSizeDDSDataExVectorDouble(size_t size) { MaxSizeDDSDataExVectorDouble = size; };
        void SetMaxSizeDDSDataExVectorChar(size_t size) { MaxSizeDDSDataExVectorChar = size; };

        size_t GetMaxSizeDDSDataExVectorInt() { return MaxSizeDDSDataExVectorInt; };
        size_t GetMaxSizeDDSDataExVectorFloat() { return MaxSizeDDSDataExVectorFloat; };
        size_t GetMaxSizeDDSDataExVectorDouble() { return MaxSizeDDSDataExVectorDouble; };
        size_t GetMaxSizeDDSDataExVectorChar() { return MaxSizeDDSDataExVectorChar; };

        void SetMaxSizeDDSAlarmVectorAlarms(size_t size) { MaxSizeDDSAlarmVectorAlarm = size; };
        void SetMaxSizeDDSExVectorAlarms(size_t size) { MaxSizeDDSExVectorAlarms = size; };

        size_t GetMaxSizeDDSAlarmAlarms() { return MaxSizeDDSAlarmVectorAlarm; };
        size_t GetMaxSizeDDSExVectorAlarms() { return MaxSizeDDSExVectorAlarms; };

    }
}


TopicCommand::TopicCommand()
{
    // m_time_messege com.eprosima.idl.parser.typecode.PrimitiveTypeCode@319b92f3
    m_time_messege = 0;
    // m_id_source com.eprosima.idl.parser.typecode.PrimitiveTypeCode@fcd6521
    m_id_source = 0;
    // m_id_target com.eprosima.idl.parser.typecode.PrimitiveTypeCode@27d415d9
    m_id_target = 0;
    // m_code_command com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5c18298f
    m_code_command = 0;
    // m_parameter com.eprosima.idl.parser.typecode.ArrayTypeCode@31f924f5
    memset(&m_parameter, 0, (256) * 1);

    // Just to register all known types
    registerTypeTopicsTypes();
}

TopicCommand::~TopicCommand()
{





}

TopicCommand::TopicCommand(
        const TopicCommand& x)
{
    m_time_messege = x.m_time_messege;
    m_id_source = x.m_id_source;
    m_id_target = x.m_id_target;
    m_code_command = x.m_code_command;
    m_parameter = x.m_parameter;
}

TopicCommand::TopicCommand(
        TopicCommand&& x)
{
    m_time_messege = x.m_time_messege;
    m_id_source = x.m_id_source;
    m_id_target = x.m_id_target;
    m_code_command = x.m_code_command;
    m_parameter = std::move(x.m_parameter);
}

TopicCommand& TopicCommand::operator =(
        const TopicCommand& x)
{

    m_time_messege = x.m_time_messege;
    m_id_source = x.m_id_source;
    m_id_target = x.m_id_target;
    m_code_command = x.m_code_command;
    m_parameter = x.m_parameter;

    return *this;
}

TopicCommand& TopicCommand::operator =(
        TopicCommand&& x)
{

    m_time_messege = x.m_time_messege;
    m_id_source = x.m_id_source;
    m_id_target = x.m_id_target;
    m_code_command = x.m_code_command;
    m_parameter = std::move(x.m_parameter);

    return *this;
}

size_t TopicCommand::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += ((256) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t TopicCommand::getCdrSerializedSize(
        const TopicCommand& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    if ((256) > 0)
    {
        current_alignment += ((256) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }


    return current_alignment - initial_alignment;
}

void TopicCommand::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_time_messege;
    scdr << m_id_source;
    scdr << m_id_target;
    scdr << m_code_command;
    scdr << m_parameter;


}

void TopicCommand::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_time_messege;
    dcdr >> m_id_source;
    dcdr >> m_id_target;
    dcdr >> m_code_command;
    dcdr >> m_parameter;

}

/*!
 * @brief This function sets a value in member time_messege
 * @param _time_messege New value for member time_messege
 */
void TopicCommand::time_messege(
        int64_t _time_messege)
{
    m_time_messege = _time_messege;
}

/*!
 * @brief This function returns the value of member time_messege
 * @return Value of member time_messege
 */
int64_t TopicCommand::time_messege() const
{
    return m_time_messege;
}

/*!
 * @brief This function returns a reference to member time_messege
 * @return Reference to member time_messege
 */
int64_t& TopicCommand::time_messege()
{
    return m_time_messege;
}

/*!
 * @brief This function sets a value in member id_source
 * @param _id_source New value for member id_source
 */
void TopicCommand::id_source(
        uint32_t _id_source)
{
    m_id_source = _id_source;
}

/*!
 * @brief This function returns the value of member id_source
 * @return Value of member id_source
 */
uint32_t TopicCommand::id_source() const
{
    return m_id_source;
}

/*!
 * @brief This function returns a reference to member id_source
 * @return Reference to member id_source
 */
uint32_t& TopicCommand::id_source()
{
    return m_id_source;
}

/*!
 * @brief This function sets a value in member id_target
 * @param _id_target New value for member id_target
 */
void TopicCommand::id_target(
        uint32_t _id_target)
{
    m_id_target = _id_target;
}

/*!
 * @brief This function returns the value of member id_target
 * @return Value of member id_target
 */
uint32_t TopicCommand::id_target() const
{
    return m_id_target;
}

/*!
 * @brief This function returns a reference to member id_target
 * @return Reference to member id_target
 */
uint32_t& TopicCommand::id_target()
{
    return m_id_target;
}

/*!
 * @brief This function sets a value in member code_command
 * @param _code_command New value for member code_command
 */
void TopicCommand::code_command(
        uint32_t _code_command)
{
    m_code_command = _code_command;
}

/*!
 * @brief This function returns the value of member code_command
 * @return Value of member code_command
 */
uint32_t TopicCommand::code_command() const
{
    return m_code_command;
}

/*!
 * @brief This function returns a reference to member code_command
 * @return Reference to member code_command
 */
uint32_t& TopicCommand::code_command()
{
    return m_code_command;
}

/*!
 * @brief This function copies the value in member parameter
 * @param _parameter New value to be copied in member parameter
 */
void TopicCommand::parameter(
        const std::array<char, 256>& _parameter)
{
    m_parameter = _parameter;
}

/*!
 * @brief This function moves the value in member parameter
 * @param _parameter New value to be moved in member parameter
 */
void TopicCommand::parameter(
        std::array<char, 256>&& _parameter)
{
    m_parameter = std::move(_parameter);
}

/*!
 * @brief This function returns a constant reference to member parameter
 * @return Constant reference to member parameter
 */
const std::array<char, 256>& TopicCommand::parameter() const
{
    return m_parameter;
}

/*!
 * @brief This function returns a reference to member parameter
 * @return Reference to member parameter
 */
std::array<char, 256>& TopicCommand::parameter()
{
    return m_parameter;
}

size_t TopicCommand::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;








    return current_align;
}

bool TopicCommand::isKeyDefined()
{
    return false;
}

void TopicCommand::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
         
}

TopicStatus::TopicStatus()
{
    // m_time_messege com.eprosima.idl.parser.typecode.PrimitiveTypeCode@44a3ec6b
    m_time_messege = 0;
    // m_id_source com.eprosima.idl.parser.typecode.PrimitiveTypeCode@71623278
    m_id_source = 0;
    // m_id_target com.eprosima.idl.parser.typecode.PrimitiveTypeCode@768b970c
    m_id_target = 0;
    // m_code_command com.eprosima.idl.parser.typecode.PrimitiveTypeCode@61ca2dfa
    m_code_command = 0;
    // m_code_status com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4b53f538
    m_code_status = 0;
    // m_description com.eprosima.idl.parser.typecode.ArrayTypeCode@134593bf
    memset(&m_description, 0, (256) * 1);

    // Just to register all known types
    registerTypeTopicsTypes();
}

TopicStatus::~TopicStatus()
{






}

TopicStatus::TopicStatus(
        const TopicStatus& x)
{
    m_time_messege = x.m_time_messege;
    m_id_source = x.m_id_source;
    m_id_target = x.m_id_target;
    m_code_command = x.m_code_command;
    m_code_status = x.m_code_status;
    m_description = x.m_description;
}

TopicStatus::TopicStatus(
        TopicStatus&& x)
{
    m_time_messege = x.m_time_messege;
    m_id_source = x.m_id_source;
    m_id_target = x.m_id_target;
    m_code_command = x.m_code_command;
    m_code_status = x.m_code_status;
    m_description = std::move(x.m_description);
}

TopicStatus& TopicStatus::operator =(
        const TopicStatus& x)
{

    m_time_messege = x.m_time_messege;
    m_id_source = x.m_id_source;
    m_id_target = x.m_id_target;
    m_code_command = x.m_code_command;
    m_code_status = x.m_code_status;
    m_description = x.m_description;

    return *this;
}

TopicStatus& TopicStatus::operator =(
        TopicStatus&& x)
{

    m_time_messege = x.m_time_messege;
    m_id_source = x.m_id_source;
    m_id_target = x.m_id_target;
    m_code_command = x.m_code_command;
    m_code_status = x.m_code_status;
    m_description = std::move(x.m_description);

    return *this;
}

size_t TopicStatus::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += ((256) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t TopicStatus::getCdrSerializedSize(
        const TopicStatus& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    if ((256) > 0)
    {
        current_alignment += ((256) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }


    return current_alignment - initial_alignment;
}

void TopicStatus::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_time_messege;
    scdr << m_id_source;
    scdr << m_id_target;
    scdr << m_code_command;
    scdr << m_code_status;
    scdr << m_description;


}

void TopicStatus::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_time_messege;
    dcdr >> m_id_source;
    dcdr >> m_id_target;
    dcdr >> m_code_command;
    dcdr >> m_code_status;
    dcdr >> m_description;

}

/*!
 * @brief This function sets a value in member time_messege
 * @param _time_messege New value for member time_messege
 */
void TopicStatus::time_messege(
        int64_t _time_messege)
{
    m_time_messege = _time_messege;
}

/*!
 * @brief This function returns the value of member time_messege
 * @return Value of member time_messege
 */
int64_t TopicStatus::time_messege() const
{
    return m_time_messege;
}

/*!
 * @brief This function returns a reference to member time_messege
 * @return Reference to member time_messege
 */
int64_t& TopicStatus::time_messege()
{
    return m_time_messege;
}

/*!
 * @brief This function sets a value in member id_source
 * @param _id_source New value for member id_source
 */
void TopicStatus::id_source(
        uint32_t _id_source)
{
    m_id_source = _id_source;
}

/*!
 * @brief This function returns the value of member id_source
 * @return Value of member id_source
 */
uint32_t TopicStatus::id_source() const
{
    return m_id_source;
}

/*!
 * @brief This function returns a reference to member id_source
 * @return Reference to member id_source
 */
uint32_t& TopicStatus::id_source()
{
    return m_id_source;
}

/*!
 * @brief This function sets a value in member id_target
 * @param _id_target New value for member id_target
 */
void TopicStatus::id_target(
        uint32_t _id_target)
{
    m_id_target = _id_target;
}

/*!
 * @brief This function returns the value of member id_target
 * @return Value of member id_target
 */
uint32_t TopicStatus::id_target() const
{
    return m_id_target;
}

/*!
 * @brief This function returns a reference to member id_target
 * @return Reference to member id_target
 */
uint32_t& TopicStatus::id_target()
{
    return m_id_target;
}

/*!
 * @brief This function sets a value in member code_command
 * @param _code_command New value for member code_command
 */
void TopicStatus::code_command(
        uint32_t _code_command)
{
    m_code_command = _code_command;
}

/*!
 * @brief This function returns the value of member code_command
 * @return Value of member code_command
 */
uint32_t TopicStatus::code_command() const
{
    return m_code_command;
}

/*!
 * @brief This function returns a reference to member code_command
 * @return Reference to member code_command
 */
uint32_t& TopicStatus::code_command()
{
    return m_code_command;
}

/*!
 * @brief This function sets a value in member code_status
 * @param _code_status New value for member code_status
 */
void TopicStatus::code_status(
        uint32_t _code_status)
{
    m_code_status = _code_status;
}

/*!
 * @brief This function returns the value of member code_status
 * @return Value of member code_status
 */
uint32_t TopicStatus::code_status() const
{
    return m_code_status;
}

/*!
 * @brief This function returns a reference to member code_status
 * @return Reference to member code_status
 */
uint32_t& TopicStatus::code_status()
{
    return m_code_status;
}

/*!
 * @brief This function copies the value in member description
 * @param _description New value to be copied in member description
 */
void TopicStatus::description(
        const std::array<char, 256>& _description)
{
    m_description = _description;
}

/*!
 * @brief This function moves the value in member description
 * @param _description New value to be moved in member description
 */
void TopicStatus::description(
        std::array<char, 256>&& _description)
{
    m_description = std::move(_description);
}

/*!
 * @brief This function returns a constant reference to member description
 * @return Constant reference to member description
 */
const std::array<char, 256>& TopicStatus::description() const
{
    return m_description;
}

/*!
 * @brief This function returns a reference to member description
 * @return Reference to member description
 */
std::array<char, 256>& TopicStatus::description()
{
    return m_description;
}

size_t TopicStatus::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;









    return current_align;
}

bool TopicStatus::isKeyDefined()
{
    return false;
}

void TopicStatus::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
          
}

DataCollectionInt::DataCollectionInt()
{
    // m_value com.eprosima.idl.parser.typecode.SequenceTypeCode@6cc7b4de

    // m_quality com.eprosima.idl.parser.typecode.SequenceTypeCode@32cf48b7


    // Just to register all known types
    registerTypeTopicsTypes();
}

DataCollectionInt::~DataCollectionInt()
{


}

DataCollectionInt::DataCollectionInt(
        const DataCollectionInt& x)
{
    m_value = x.m_value;
    m_quality = x.m_quality;
}

DataCollectionInt::DataCollectionInt(
        DataCollectionInt&& x)
{
    m_value = std::move(x.m_value);
    m_quality = std::move(x.m_quality);
}

DataCollectionInt& DataCollectionInt::operator =(
        const DataCollectionInt& x)
{

    m_value = x.m_value;
    m_quality = x.m_quality;

    return *this;
}

DataCollectionInt& DataCollectionInt::operator =(
        DataCollectionInt&& x)
{

    m_value = std::move(x.m_value);
    m_quality = std::move(x.m_quality);

    return *this;
}

size_t DataCollectionInt::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (scada_ate::typetopics::GetMaxSizeDataCollectionInt() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (scada_ate::typetopics::GetMaxSizeDataCollectionInt() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

size_t DataCollectionInt::getCdrSerializedSize(
        const DataCollectionInt& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.value().size() > 0)
    {
        current_alignment += (data.value().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.quality().size() > 0)
    {
        current_alignment += (data.quality().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }




    return current_alignment - initial_alignment;
}

void DataCollectionInt::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
    scdr << m_quality;
}

void DataCollectionInt::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
    dcdr >> m_quality;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void DataCollectionInt::value(
        const std::vector<int32_t>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void DataCollectionInt::value(
        std::vector<int32_t>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::vector<int32_t>& DataCollectionInt::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::vector<int32_t>& DataCollectionInt::value()
{
    return m_value;
}
/*!
 * @brief This function copies the value in member quality
 * @param _quality New value to be copied in member quality
 */
void DataCollectionInt::quality(
        const std::vector<char>& _quality)
{
    m_quality = _quality;
}

/*!
 * @brief This function moves the value in member quality
 * @param _quality New value to be moved in member quality
 */
void DataCollectionInt::quality(
        std::vector<char>&& _quality)
{
    m_quality = std::move(_quality);
}

/*!
 * @brief This function returns a constant reference to member quality
 * @return Constant reference to member quality
 */
const std::vector<char>& DataCollectionInt::quality() const
{
    return m_quality;
}

/*!
 * @brief This function returns a reference to member quality
 * @return Reference to member quality
 */
std::vector<char>& DataCollectionInt::quality()
{
    return m_quality;
}

size_t DataCollectionInt::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool DataCollectionInt::isKeyDefined()
{
    return false;
}

void DataCollectionInt::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

DataCollectionFloat::DataCollectionFloat()
{
    // m_value com.eprosima.idl.parser.typecode.SequenceTypeCode@799d4f69

    // m_quality com.eprosima.idl.parser.typecode.SequenceTypeCode@49c43f4e


    // Just to register all known types
    registerTypeTopicsTypes();
}

DataCollectionFloat::~DataCollectionFloat()
{


}

DataCollectionFloat::DataCollectionFloat(
        const DataCollectionFloat& x)
{
    m_value = x.m_value;
    m_quality = x.m_quality;
}

DataCollectionFloat::DataCollectionFloat(
        DataCollectionFloat&& x)
{
    m_value = std::move(x.m_value);
    m_quality = std::move(x.m_quality);
}

DataCollectionFloat& DataCollectionFloat::operator =(
        const DataCollectionFloat& x)
{

    m_value = x.m_value;
    m_quality = x.m_quality;

    return *this;
}

DataCollectionFloat& DataCollectionFloat::operator =(
        DataCollectionFloat&& x)
{

    m_value = std::move(x.m_value);
    m_quality = std::move(x.m_quality);

    return *this;
}

size_t DataCollectionFloat::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (scada_ate::typetopics::GetMaxSizeDataCollectionFloat() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (scada_ate::typetopics::GetMaxSizeDataCollectionFloat() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

size_t DataCollectionFloat::getCdrSerializedSize(
        const DataCollectionFloat& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.value().size() > 0)
    {
        current_alignment += (data.value().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.quality().size() > 0)
    {
        current_alignment += (data.quality().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }




    return current_alignment - initial_alignment;
}

void DataCollectionFloat::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
    scdr << m_quality;
}

void DataCollectionFloat::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
    dcdr >> m_quality;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void DataCollectionFloat::value(
        const std::vector<float>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void DataCollectionFloat::value(
        std::vector<float>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::vector<float>& DataCollectionFloat::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::vector<float>& DataCollectionFloat::value()
{
    return m_value;
}
/*!
 * @brief This function copies the value in member quality
 * @param _quality New value to be copied in member quality
 */
void DataCollectionFloat::quality(
        const std::vector<char>& _quality)
{
    m_quality = _quality;
}

/*!
 * @brief This function moves the value in member quality
 * @param _quality New value to be moved in member quality
 */
void DataCollectionFloat::quality(
        std::vector<char>&& _quality)
{
    m_quality = std::move(_quality);
}

/*!
 * @brief This function returns a constant reference to member quality
 * @return Constant reference to member quality
 */
const std::vector<char>& DataCollectionFloat::quality() const
{
    return m_quality;
}

/*!
 * @brief This function returns a reference to member quality
 * @return Reference to member quality
 */
std::vector<char>& DataCollectionFloat::quality()
{
    return m_quality;
}

size_t DataCollectionFloat::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool DataCollectionFloat::isKeyDefined()
{
    return false;
}

void DataCollectionFloat::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

DataCollectionDouble::DataCollectionDouble()
{
    // m_value com.eprosima.idl.parser.typecode.SequenceTypeCode@4e41089d

    // m_quality com.eprosima.idl.parser.typecode.SequenceTypeCode@32a068d1


    // Just to register all known types
    registerTypeTopicsTypes();
}

DataCollectionDouble::~DataCollectionDouble()
{


}

DataCollectionDouble::DataCollectionDouble(
        const DataCollectionDouble& x)
{
    m_value = x.m_value;
    m_quality = x.m_quality;
}

DataCollectionDouble::DataCollectionDouble(
        DataCollectionDouble&& x)
{
    m_value = std::move(x.m_value);
    m_quality = std::move(x.m_quality);
}

DataCollectionDouble& DataCollectionDouble::operator =(
        const DataCollectionDouble& x)
{

    m_value = x.m_value;
    m_quality = x.m_quality;

    return *this;
}

DataCollectionDouble& DataCollectionDouble::operator =(
        DataCollectionDouble&& x)
{

    m_value = std::move(x.m_value);
    m_quality = std::move(x.m_quality);

    return *this;
}

size_t DataCollectionDouble::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (scada_ate::typetopics::GetMaxSizeDataCollectionDouble() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (scada_ate::typetopics::GetMaxSizeDataCollectionDouble() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

size_t DataCollectionDouble::getCdrSerializedSize(
        const DataCollectionDouble& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.value().size() > 0)
    {
        current_alignment += (data.value().size() * 8) + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.quality().size() > 0)
    {
        current_alignment += (data.quality().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }




    return current_alignment - initial_alignment;
}

void DataCollectionDouble::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
    scdr << m_quality;
}

void DataCollectionDouble::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
    dcdr >> m_quality;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void DataCollectionDouble::value(
        const std::vector<double>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void DataCollectionDouble::value(
        std::vector<double>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::vector<double>& DataCollectionDouble::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::vector<double>& DataCollectionDouble::value()
{
    return m_value;
}
/*!
 * @brief This function copies the value in member quality
 * @param _quality New value to be copied in member quality
 */
void DataCollectionDouble::quality(
        const std::vector<char>& _quality)
{
    m_quality = _quality;
}

/*!
 * @brief This function moves the value in member quality
 * @param _quality New value to be moved in member quality
 */
void DataCollectionDouble::quality(
        std::vector<char>&& _quality)
{
    m_quality = std::move(_quality);
}

/*!
 * @brief This function returns a constant reference to member quality
 * @return Constant reference to member quality
 */
const std::vector<char>& DataCollectionDouble::quality() const
{
    return m_quality;
}

/*!
 * @brief This function returns a reference to member quality
 * @return Reference to member quality
 */
std::vector<char>& DataCollectionDouble::quality()
{
    return m_quality;
}

size_t DataCollectionDouble::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool DataCollectionDouble::isKeyDefined()
{
    return false;
}

void DataCollectionDouble::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

DataCollectionChar::DataCollectionChar()
{
    // m_value com.eprosima.idl.parser.typecode.SequenceTypeCode@3ffcd140

    // m_quality com.eprosima.idl.parser.typecode.SequenceTypeCode@23bb8443


    // Just to register all known types
    registerTypeTopicsTypes();
}

DataCollectionChar::~DataCollectionChar()
{


}

DataCollectionChar::DataCollectionChar(
        const DataCollectionChar& x)
{
    m_value = x.m_value;
    m_quality = x.m_quality;
}

DataCollectionChar::DataCollectionChar(
        DataCollectionChar&& x)
{
    m_value = std::move(x.m_value);
    m_quality = std::move(x.m_quality);
}

DataCollectionChar& DataCollectionChar::operator =(
        const DataCollectionChar& x)
{

    m_value = x.m_value;
    m_quality = x.m_quality;

    return *this;
}

DataCollectionChar& DataCollectionChar::operator =(
        DataCollectionChar&& x)
{

    m_value = std::move(x.m_value);
    m_quality = std::move(x.m_quality);

    return *this;
}

size_t DataCollectionChar::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (scada_ate::typetopics::GetMaxSizeDataCollectionChar() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (scada_ate::typetopics::GetMaxSizeDataCollectionChar() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

size_t DataCollectionChar::getCdrSerializedSize(
        const DataCollectionChar& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.value().size() > 0)
    {
        current_alignment += (data.value().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.quality().size() > 0)
    {
        current_alignment += (data.quality().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }




    return current_alignment - initial_alignment;
}

void DataCollectionChar::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_value;
    scdr << m_quality;
}

void DataCollectionChar::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_value;
    dcdr >> m_quality;
}

/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void DataCollectionChar::value(
        const std::vector<char>& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void DataCollectionChar::value(
        std::vector<char>&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::vector<char>& DataCollectionChar::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::vector<char>& DataCollectionChar::value()
{
    return m_value;
}
/*!
 * @brief This function copies the value in member quality
 * @param _quality New value to be copied in member quality
 */
void DataCollectionChar::quality(
        const std::vector<char>& _quality)
{
    m_quality = _quality;
}

/*!
 * @brief This function moves the value in member quality
 * @param _quality New value to be moved in member quality
 */
void DataCollectionChar::quality(
        std::vector<char>&& _quality)
{
    m_quality = std::move(_quality);
}

/*!
 * @brief This function returns a constant reference to member quality
 * @return Constant reference to member quality
 */
const std::vector<char>& DataCollectionChar::quality() const
{
    return m_quality;
}

/*!
 * @brief This function returns a reference to member quality
 * @return Reference to member quality
 */
std::vector<char>& DataCollectionChar::quality()
{
    return m_quality;
}

size_t DataCollectionChar::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool DataCollectionChar::isKeyDefined()
{
    return false;
}

void DataCollectionChar::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

DataExInt::DataExInt()
{
    // m_time_source com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1176dcec
    m_time_source = 0;
    // m_id_tag com.eprosima.idl.parser.typecode.PrimitiveTypeCode@120d6fe6
    m_id_tag = 0;
    // m_value com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4ba2ca36
    m_value = 0;
    // m_quality com.eprosima.idl.parser.typecode.PrimitiveTypeCode@3444d69d
    m_quality = 0;

    // Just to register all known types
    registerTypeTopicsTypes();
}

DataExInt::~DataExInt()
{




}

DataExInt::DataExInt(
        const DataExInt& x)
{
    m_time_source = x.m_time_source;
    m_id_tag = x.m_id_tag;
    m_value = x.m_value;
    m_quality = x.m_quality;
}

DataExInt::DataExInt(
        DataExInt&& x)
{
    m_time_source = x.m_time_source;
    m_id_tag = x.m_id_tag;
    m_value = x.m_value;
    m_quality = x.m_quality;
}

DataExInt& DataExInt::operator =(
        const DataExInt& x)
{

    m_time_source = x.m_time_source;
    m_id_tag = x.m_id_tag;
    m_value = x.m_value;
    m_quality = x.m_quality;

    return *this;
}

DataExInt& DataExInt::operator =(
        DataExInt&& x)
{

    m_time_source = x.m_time_source;
    m_id_tag = x.m_id_tag;
    m_value = x.m_value;
    m_quality = x.m_quality;

    return *this;
}

size_t DataExInt::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t DataExInt::getCdrSerializedSize(
        const DataExInt& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void DataExInt::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_time_source;
    scdr << m_id_tag;
    scdr << m_value;
    scdr << m_quality;

}

void DataExInt::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_time_source;
    dcdr >> m_id_tag;
    dcdr >> m_value;
    dcdr >> m_quality;
}

/*!
 * @brief This function sets a value in member time_source
 * @param _time_source New value for member time_source
 */
void DataExInt::time_source(
        int64_t _time_source)
{
    m_time_source = _time_source;
}

/*!
 * @brief This function returns the value of member time_source
 * @return Value of member time_source
 */
int64_t DataExInt::time_source() const
{
    return m_time_source;
}

/*!
 * @brief This function returns a reference to member time_source
 * @return Reference to member time_source
 */
int64_t& DataExInt::time_source()
{
    return m_time_source;
}

/*!
 * @brief This function sets a value in member id_tag
 * @param _id_tag New value for member id_tag
 */
void DataExInt::id_tag(
        uint32_t _id_tag)
{
    m_id_tag = _id_tag;
}

/*!
 * @brief This function returns the value of member id_tag
 * @return Value of member id_tag
 */
uint32_t DataExInt::id_tag() const
{
    return m_id_tag;
}

/*!
 * @brief This function returns a reference to member id_tag
 * @return Reference to member id_tag
 */
uint32_t& DataExInt::id_tag()
{
    return m_id_tag;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void DataExInt::value(
        int32_t _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
int32_t DataExInt::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
int32_t& DataExInt::value()
{
    return m_value;
}

/*!
 * @brief This function sets a value in member quality
 * @param _quality New value for member quality
 */
void DataExInt::quality(
        char _quality)
{
    m_quality = _quality;
}

/*!
 * @brief This function returns the value of member quality
 * @return Value of member quality
 */
char DataExInt::quality() const
{
    return m_quality;
}

/*!
 * @brief This function returns a reference to member quality
 * @return Reference to member quality
 */
char& DataExInt::quality()
{
    return m_quality;
}


size_t DataExInt::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;







    return current_align;
}

bool DataExInt::isKeyDefined()
{
    return false;
}

void DataExInt::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
        
}

DataExFloat::DataExFloat()
{
    // m_time_source com.eprosima.idl.parser.typecode.PrimitiveTypeCode@12405818
    m_time_source = 0;
    // m_id_tag com.eprosima.idl.parser.typecode.PrimitiveTypeCode@6b67034
    m_id_tag = 0;
    // m_value com.eprosima.idl.parser.typecode.PrimitiveTypeCode@16267862
    m_value = 0.0;
    // m_quality com.eprosima.idl.parser.typecode.PrimitiveTypeCode@442675e1
    m_quality = 0;

    // Just to register all known types
    registerTypeTopicsTypes();
}

DataExFloat::~DataExFloat()
{




}

DataExFloat::DataExFloat(
        const DataExFloat& x)
{
    m_time_source = x.m_time_source;
    m_id_tag = x.m_id_tag;
    m_value = x.m_value;
    m_quality = x.m_quality;
}

DataExFloat::DataExFloat(
        DataExFloat&& x)
{
    m_time_source = x.m_time_source;
    m_id_tag = x.m_id_tag;
    m_value = x.m_value;
    m_quality = x.m_quality;
}

DataExFloat& DataExFloat::operator =(
        const DataExFloat& x)
{

    m_time_source = x.m_time_source;
    m_id_tag = x.m_id_tag;
    m_value = x.m_value;
    m_quality = x.m_quality;

    return *this;
}

DataExFloat& DataExFloat::operator =(
        DataExFloat&& x)
{

    m_time_source = x.m_time_source;
    m_id_tag = x.m_id_tag;
    m_value = x.m_value;
    m_quality = x.m_quality;

    return *this;
}

size_t DataExFloat::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t DataExFloat::getCdrSerializedSize(
        const DataExFloat& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void DataExFloat::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_time_source;
    scdr << m_id_tag;
    scdr << m_value;
    scdr << m_quality;

}

void DataExFloat::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_time_source;
    dcdr >> m_id_tag;
    dcdr >> m_value;
    dcdr >> m_quality;
}

/*!
 * @brief This function sets a value in member time_source
 * @param _time_source New value for member time_source
 */
void DataExFloat::time_source(
        int64_t _time_source)
{
    m_time_source = _time_source;
}

/*!
 * @brief This function returns the value of member time_source
 * @return Value of member time_source
 */
int64_t DataExFloat::time_source() const
{
    return m_time_source;
}

/*!
 * @brief This function returns a reference to member time_source
 * @return Reference to member time_source
 */
int64_t& DataExFloat::time_source()
{
    return m_time_source;
}

/*!
 * @brief This function sets a value in member id_tag
 * @param _id_tag New value for member id_tag
 */
void DataExFloat::id_tag(
        uint32_t _id_tag)
{
    m_id_tag = _id_tag;
}

/*!
 * @brief This function returns the value of member id_tag
 * @return Value of member id_tag
 */
uint32_t DataExFloat::id_tag() const
{
    return m_id_tag;
}

/*!
 * @brief This function returns a reference to member id_tag
 * @return Reference to member id_tag
 */
uint32_t& DataExFloat::id_tag()
{
    return m_id_tag;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void DataExFloat::value(
        float _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
float DataExFloat::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
float& DataExFloat::value()
{
    return m_value;
}

/*!
 * @brief This function sets a value in member quality
 * @param _quality New value for member quality
 */
void DataExFloat::quality(
        char _quality)
{
    m_quality = _quality;
}

/*!
 * @brief This function returns the value of member quality
 * @return Value of member quality
 */
char DataExFloat::quality() const
{
    return m_quality;
}

/*!
 * @brief This function returns a reference to member quality
 * @return Reference to member quality
 */
char& DataExFloat::quality()
{
    return m_quality;
}


size_t DataExFloat::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;







    return current_align;
}

bool DataExFloat::isKeyDefined()
{
    return false;
}

void DataExFloat::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
        
}

DataExDouble::DataExDouble()
{
    // m_time_source com.eprosima.idl.parser.typecode.PrimitiveTypeCode@3d3fcdb0
    m_time_source = 0;
    // m_id_tag com.eprosima.idl.parser.typecode.PrimitiveTypeCode@641147d0
    m_id_tag = 0;
    // m_value com.eprosima.idl.parser.typecode.PrimitiveTypeCode@6e38921c
    m_value = 0.0;
    // m_quality com.eprosima.idl.parser.typecode.PrimitiveTypeCode@64d7f7e0
    m_quality = 0;

    // Just to register all known types
    registerTypeTopicsTypes();
}

DataExDouble::~DataExDouble()
{




}

DataExDouble::DataExDouble(
        const DataExDouble& x)
{
    m_time_source = x.m_time_source;
    m_id_tag = x.m_id_tag;
    m_value = x.m_value;
    m_quality = x.m_quality;
}

DataExDouble::DataExDouble(
        DataExDouble&& x)
{
    m_time_source = x.m_time_source;
    m_id_tag = x.m_id_tag;
    m_value = x.m_value;
    m_quality = x.m_quality;
}

DataExDouble& DataExDouble::operator =(
        const DataExDouble& x)
{

    m_time_source = x.m_time_source;
    m_id_tag = x.m_id_tag;
    m_value = x.m_value;
    m_quality = x.m_quality;

    return *this;
}

DataExDouble& DataExDouble::operator =(
        DataExDouble&& x)
{

    m_time_source = x.m_time_source;
    m_id_tag = x.m_id_tag;
    m_value = x.m_value;
    m_quality = x.m_quality;

    return *this;
}

size_t DataExDouble::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t DataExDouble::getCdrSerializedSize(
        const DataExDouble& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void DataExDouble::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_time_source;
    scdr << m_id_tag;
    scdr << m_value;
    scdr << m_quality;

}

void DataExDouble::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_time_source;
    dcdr >> m_id_tag;
    dcdr >> m_value;
    dcdr >> m_quality;
}

/*!
 * @brief This function sets a value in member time_source
 * @param _time_source New value for member time_source
 */
void DataExDouble::time_source(
        int64_t _time_source)
{
    m_time_source = _time_source;
}

/*!
 * @brief This function returns the value of member time_source
 * @return Value of member time_source
 */
int64_t DataExDouble::time_source() const
{
    return m_time_source;
}

/*!
 * @brief This function returns a reference to member time_source
 * @return Reference to member time_source
 */
int64_t& DataExDouble::time_source()
{
    return m_time_source;
}

/*!
 * @brief This function sets a value in member id_tag
 * @param _id_tag New value for member id_tag
 */
void DataExDouble::id_tag(
        uint32_t _id_tag)
{
    m_id_tag = _id_tag;
}

/*!
 * @brief This function returns the value of member id_tag
 * @return Value of member id_tag
 */
uint32_t DataExDouble::id_tag() const
{
    return m_id_tag;
}

/*!
 * @brief This function returns a reference to member id_tag
 * @return Reference to member id_tag
 */
uint32_t& DataExDouble::id_tag()
{
    return m_id_tag;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void DataExDouble::value(
        double _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
double DataExDouble::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
double& DataExDouble::value()
{
    return m_value;
}

/*!
 * @brief This function sets a value in member quality
 * @param _quality New value for member quality
 */
void DataExDouble::quality(
        char _quality)
{
    m_quality = _quality;
}

/*!
 * @brief This function returns the value of member quality
 * @return Value of member quality
 */
char DataExDouble::quality() const
{
    return m_quality;
}

/*!
 * @brief This function returns a reference to member quality
 * @return Reference to member quality
 */
char& DataExDouble::quality()
{
    return m_quality;
}


size_t DataExDouble::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;







    return current_align;
}

bool DataExDouble::isKeyDefined()
{
    return false;
}

void DataExDouble::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
        
}

DataExChar::DataExChar()
{
    // m_time_source com.eprosima.idl.parser.typecode.PrimitiveTypeCode@27c6e487
    m_time_source = 0;
    // m_id_tag com.eprosima.idl.parser.typecode.PrimitiveTypeCode@49070868
    m_id_tag = 0;
    // m_value com.eprosima.idl.parser.typecode.PrimitiveTypeCode@6385cb26
    m_value = 0;
    // m_quality com.eprosima.idl.parser.typecode.PrimitiveTypeCode@38364841
    m_quality = 0;

    // Just to register all known types
    registerTypeTopicsTypes();
}

DataExChar::~DataExChar()
{




}

DataExChar::DataExChar(
        const DataExChar& x)
{
    m_time_source = x.m_time_source;
    m_id_tag = x.m_id_tag;
    m_value = x.m_value;
    m_quality = x.m_quality;
}

DataExChar::DataExChar(
        DataExChar&& x)
{
    m_time_source = x.m_time_source;
    m_id_tag = x.m_id_tag;
    m_value = x.m_value;
    m_quality = x.m_quality;
}

DataExChar& DataExChar::operator =(
        const DataExChar& x)
{

    m_time_source = x.m_time_source;
    m_id_tag = x.m_id_tag;
    m_value = x.m_value;
    m_quality = x.m_quality;

    return *this;
}

DataExChar& DataExChar::operator =(
        DataExChar&& x)
{

    m_time_source = x.m_time_source;
    m_id_tag = x.m_id_tag;
    m_value = x.m_value;
    m_quality = x.m_quality;

    return *this;
}

size_t DataExChar::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t DataExChar::getCdrSerializedSize(
        const DataExChar& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void DataExChar::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_time_source;
    scdr << m_id_tag;
    scdr << m_value;
    scdr << m_quality;

}

void DataExChar::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_time_source;
    dcdr >> m_id_tag;
    dcdr >> m_value;
    dcdr >> m_quality;
}

/*!
 * @brief This function sets a value in member time_source
 * @param _time_source New value for member time_source
 */
void DataExChar::time_source(
        int64_t _time_source)
{
    m_time_source = _time_source;
}

/*!
 * @brief This function returns the value of member time_source
 * @return Value of member time_source
 */
int64_t DataExChar::time_source() const
{
    return m_time_source;
}

/*!
 * @brief This function returns a reference to member time_source
 * @return Reference to member time_source
 */
int64_t& DataExChar::time_source()
{
    return m_time_source;
}

/*!
 * @brief This function sets a value in member id_tag
 * @param _id_tag New value for member id_tag
 */
void DataExChar::id_tag(
        uint32_t _id_tag)
{
    m_id_tag = _id_tag;
}

/*!
 * @brief This function returns the value of member id_tag
 * @return Value of member id_tag
 */
uint32_t DataExChar::id_tag() const
{
    return m_id_tag;
}

/*!
 * @brief This function returns a reference to member id_tag
 * @return Reference to member id_tag
 */
uint32_t& DataExChar::id_tag()
{
    return m_id_tag;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void DataExChar::value(
        char _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
char DataExChar::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
char& DataExChar::value()
{
    return m_value;
}

/*!
 * @brief This function sets a value in member quality
 * @param _quality New value for member quality
 */
void DataExChar::quality(
        char _quality)
{
    m_quality = _quality;
}

/*!
 * @brief This function returns the value of member quality
 * @return Value of member quality
 */
char DataExChar::quality() const
{
    return m_quality;
}

/*!
 * @brief This function returns a reference to member quality
 * @return Reference to member quality
 */
char& DataExChar::quality()
{
    return m_quality;
}


size_t DataExChar::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;







    return current_align;
}

bool DataExChar::isKeyDefined()
{
    return false;
}

void DataExChar::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
        
}

DDSData::DDSData()
{
    // m_time_source com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4b168fa9
    m_time_source = 0;
    // m_time_service com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1a84f40f
    m_time_service = 0;
    // m_data_int com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@23282c25

    // m_data_float com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@7920ba90

    // m_data_double com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@6b419da

    // m_data_char com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@3b2da18f


    // Just to register all known types
    registerTypeTopicsTypes();
}

DDSData::~DDSData()
{






}

DDSData::DDSData(
        const DDSData& x)
{
    m_time_source = x.m_time_source;
    m_time_service = x.m_time_service;
    m_data_int = x.m_data_int;
    m_data_float = x.m_data_float;
    m_data_double = x.m_data_double;
    m_data_char = x.m_data_char;
}

DDSData::DDSData(
        DDSData&& x)
{
    m_time_source = x.m_time_source;
    m_time_service = x.m_time_service;
    m_data_int = std::move(x.m_data_int);
    m_data_float = std::move(x.m_data_float);
    m_data_double = std::move(x.m_data_double);
    m_data_char = std::move(x.m_data_char);
}

DDSData& DDSData::operator =(
        const DDSData& x)
{

    m_time_source = x.m_time_source;
    m_time_service = x.m_time_service;
    m_data_int = x.m_data_int;
    m_data_float = x.m_data_float;
    m_data_double = x.m_data_double;
    m_data_char = x.m_data_char;

    return *this;
}

DDSData& DDSData::operator =(
        DDSData&& x)
{

    m_time_source = x.m_time_source;
    m_time_service = x.m_time_service;
    m_data_int = std::move(x.m_data_int);
    m_data_float = std::move(x.m_data_float);
    m_data_double = std::move(x.m_data_double);
    m_data_char = std::move(x.m_data_char);

    return *this;
}

size_t DDSData::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += DataCollectionInt::getMaxCdrSerializedSize(current_alignment);
    current_alignment += DataCollectionFloat::getMaxCdrSerializedSize(current_alignment);
    current_alignment += DataCollectionDouble::getMaxCdrSerializedSize(current_alignment);
    current_alignment += DataCollectionChar::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t DDSData::getCdrSerializedSize(
        const DDSData& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += DataCollectionInt::getCdrSerializedSize(data.data_int(), current_alignment);
    current_alignment += DataCollectionFloat::getCdrSerializedSize(data.data_float(), current_alignment);
    current_alignment += DataCollectionDouble::getCdrSerializedSize(data.data_double(), current_alignment);
    current_alignment += DataCollectionChar::getCdrSerializedSize(data.data_char(), current_alignment);

    return current_alignment - initial_alignment;
}

void DDSData::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_time_source;
    scdr << m_time_service;
    scdr << m_data_int;
    scdr << m_data_float;
    scdr << m_data_double;
    scdr << m_data_char;

}

void DDSData::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_time_source;
    dcdr >> m_time_service;
    dcdr >> m_data_int;
    dcdr >> m_data_float;
    dcdr >> m_data_double;
    dcdr >> m_data_char;
}

/*!
 * @brief This function sets a value in member time_source
 * @param _time_source New value for member time_source
 */
void DDSData::time_source(
        int64_t _time_source)
{
    m_time_source = _time_source;
}

/*!
 * @brief This function returns the value of member time_source
 * @return Value of member time_source
 */
int64_t DDSData::time_source() const
{
    return m_time_source;
}

/*!
 * @brief This function returns a reference to member time_source
 * @return Reference to member time_source
 */
int64_t& DDSData::time_source()
{
    return m_time_source;
}

/*!
 * @brief This function sets a value in member time_service
 * @param _time_service New value for member time_service
 */
void DDSData::time_service(
        int64_t _time_service)
{
    m_time_service = _time_service;
}

/*!
 * @brief This function returns the value of member time_service
 * @return Value of member time_service
 */
int64_t DDSData::time_service() const
{
    return m_time_service;
}

/*!
 * @brief This function returns a reference to member time_service
 * @return Reference to member time_service
 */
int64_t& DDSData::time_service()
{
    return m_time_service;
}

/*!
 * @brief This function copies the value in member data_int
 * @param _data_int New value to be copied in member data_int
 */
void DDSData::data_int(
        const DataCollectionInt& _data_int)
{
    m_data_int = _data_int;
}

/*!
 * @brief This function moves the value in member data_int
 * @param _data_int New value to be moved in member data_int
 */
void DDSData::data_int(
        DataCollectionInt&& _data_int)
{
    m_data_int = std::move(_data_int);
}

/*!
 * @brief This function returns a constant reference to member data_int
 * @return Constant reference to member data_int
 */
const DataCollectionInt& DDSData::data_int() const
{
    return m_data_int;
}

/*!
 * @brief This function returns a reference to member data_int
 * @return Reference to member data_int
 */
DataCollectionInt& DDSData::data_int()
{
    return m_data_int;
}
/*!
 * @brief This function copies the value in member data_float
 * @param _data_float New value to be copied in member data_float
 */
void DDSData::data_float(
        const DataCollectionFloat& _data_float)
{
    m_data_float = _data_float;
}

/*!
 * @brief This function moves the value in member data_float
 * @param _data_float New value to be moved in member data_float
 */
void DDSData::data_float(
        DataCollectionFloat&& _data_float)
{
    m_data_float = std::move(_data_float);
}

/*!
 * @brief This function returns a constant reference to member data_float
 * @return Constant reference to member data_float
 */
const DataCollectionFloat& DDSData::data_float() const
{
    return m_data_float;
}

/*!
 * @brief This function returns a reference to member data_float
 * @return Reference to member data_float
 */
DataCollectionFloat& DDSData::data_float()
{
    return m_data_float;
}
/*!
 * @brief This function copies the value in member data_double
 * @param _data_double New value to be copied in member data_double
 */
void DDSData::data_double(
        const DataCollectionDouble& _data_double)
{
    m_data_double = _data_double;
}

/*!
 * @brief This function moves the value in member data_double
 * @param _data_double New value to be moved in member data_double
 */
void DDSData::data_double(
        DataCollectionDouble&& _data_double)
{
    m_data_double = std::move(_data_double);
}

/*!
 * @brief This function returns a constant reference to member data_double
 * @return Constant reference to member data_double
 */
const DataCollectionDouble& DDSData::data_double() const
{
    return m_data_double;
}

/*!
 * @brief This function returns a reference to member data_double
 * @return Reference to member data_double
 */
DataCollectionDouble& DDSData::data_double()
{
    return m_data_double;
}
/*!
 * @brief This function copies the value in member data_char
 * @param _data_char New value to be copied in member data_char
 */
void DDSData::data_char(
        const DataCollectionChar& _data_char)
{
    m_data_char = _data_char;
}

/*!
 * @brief This function moves the value in member data_char
 * @param _data_char New value to be moved in member data_char
 */
void DDSData::data_char(
        DataCollectionChar&& _data_char)
{
    m_data_char = std::move(_data_char);
}

/*!
 * @brief This function returns a constant reference to member data_char
 * @return Constant reference to member data_char
 */
const DataCollectionChar& DDSData::data_char() const
{
    return m_data_char;
}

/*!
 * @brief This function returns a reference to member data_char
 * @return Reference to member data_char
 */
DataCollectionChar& DDSData::data_char()
{
    return m_data_char;
}

size_t DDSData::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;









    return current_align;
}

bool DDSData::isKeyDefined()
{
    return false;
}

void DDSData::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
          
}

DDSDataEx::DDSDataEx()
{
    // m_time_service com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5906ebcb
    m_time_service = 0;
    // m_data_int com.eprosima.idl.parser.typecode.SequenceTypeCode@258e2e41

    // m_data_float com.eprosima.idl.parser.typecode.SequenceTypeCode@3d299e3

    // m_data_double com.eprosima.idl.parser.typecode.SequenceTypeCode@55a561cf

    // m_data_char com.eprosima.idl.parser.typecode.SequenceTypeCode@3b938003


    // Just to register all known types
    registerTypeTopicsTypes();
}

DDSDataEx::~DDSDataEx()
{





}

DDSDataEx::DDSDataEx(
        const DDSDataEx& x)
{
    m_time_service = x.m_time_service;
    m_data_int = x.m_data_int;
    m_data_float = x.m_data_float;
    m_data_double = x.m_data_double;
    m_data_char = x.m_data_char;
}

DDSDataEx::DDSDataEx(
        DDSDataEx&& x)
{
    m_time_service = x.m_time_service;
    m_data_int = std::move(x.m_data_int);
    m_data_float = std::move(x.m_data_float);
    m_data_double = std::move(x.m_data_double);
    m_data_char = std::move(x.m_data_char);
}

DDSDataEx& DDSDataEx::operator =(
        const DDSDataEx& x)
{

    m_time_service = x.m_time_service;
    m_data_int = x.m_data_int;
    m_data_float = x.m_data_float;
    m_data_double = x.m_data_double;
    m_data_char = x.m_data_char;

    return *this;
}

DDSDataEx& DDSDataEx::operator =(
        DDSDataEx&& x)
{

    m_time_service = x.m_time_service;
    m_data_int = std::move(x.m_data_int);
    m_data_float = std::move(x.m_data_float);
    m_data_double = std::move(x.m_data_double);
    m_data_char = std::move(x.m_data_char);

    return *this;
}

size_t DDSDataEx::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < scada_ate::typetopics::GetMaxSizeDDSDataExVectorInt(); ++a)
    {
        current_alignment += DataExInt::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < scada_ate::typetopics::GetMaxSizeDDSDataExVectorFloat(); ++a)
    {
        current_alignment += DataExFloat::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < scada_ate::typetopics::GetMaxSizeDDSDataExVectorDouble(); ++a)
    {
        current_alignment += DataExDouble::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < scada_ate::typetopics::GetMaxSizeDDSDataExVectorChar(); ++a)
    {
        current_alignment += DataExChar::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t DDSDataEx::getCdrSerializedSize(
        const DDSDataEx& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.data_int().size(); ++a)
    {
        current_alignment += DataExInt::getCdrSerializedSize(data.data_int().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.data_float().size(); ++a)
    {
        current_alignment += DataExFloat::getCdrSerializedSize(data.data_float().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.data_double().size(); ++a)
    {
        current_alignment += DataExDouble::getCdrSerializedSize(data.data_double().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.data_char().size(); ++a)
    {
        current_alignment += DataExChar::getCdrSerializedSize(data.data_char().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void DDSDataEx::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_time_service;
    scdr << m_data_int;
    scdr << m_data_float;
    scdr << m_data_double;
    scdr << m_data_char;

}

void DDSDataEx::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_time_service;
    dcdr >> m_data_int;
    dcdr >> m_data_float;
    dcdr >> m_data_double;
    dcdr >> m_data_char;
}

/*!
 * @brief This function sets a value in member time_service
 * @param _time_service New value for member time_service
 */
void DDSDataEx::time_service(
        int64_t _time_service)
{
    m_time_service = _time_service;
}

/*!
 * @brief This function returns the value of member time_service
 * @return Value of member time_service
 */
int64_t DDSDataEx::time_service() const
{
    return m_time_service;
}

/*!
 * @brief This function returns a reference to member time_service
 * @return Reference to member time_service
 */
int64_t& DDSDataEx::time_service()
{
    return m_time_service;
}

/*!
 * @brief This function copies the value in member data_int
 * @param _data_int New value to be copied in member data_int
 */
void DDSDataEx::data_int(
        const std::vector<DataExInt>& _data_int)
{
    m_data_int = _data_int;
}

/*!
 * @brief This function moves the value in member data_int
 * @param _data_int New value to be moved in member data_int
 */
void DDSDataEx::data_int(
        std::vector<DataExInt>&& _data_int)
{
    m_data_int = std::move(_data_int);
}

/*!
 * @brief This function returns a constant reference to member data_int
 * @return Constant reference to member data_int
 */
const std::vector<DataExInt>& DDSDataEx::data_int() const
{
    return m_data_int;
}

/*!
 * @brief This function returns a reference to member data_int
 * @return Reference to member data_int
 */
std::vector<DataExInt>& DDSDataEx::data_int()
{
    return m_data_int;
}
/*!
 * @brief This function copies the value in member data_float
 * @param _data_float New value to be copied in member data_float
 */
void DDSDataEx::data_float(
        const std::vector<DataExFloat>& _data_float)
{
    m_data_float = _data_float;
}

/*!
 * @brief This function moves the value in member data_float
 * @param _data_float New value to be moved in member data_float
 */
void DDSDataEx::data_float(
        std::vector<DataExFloat>&& _data_float)
{
    m_data_float = std::move(_data_float);
}

/*!
 * @brief This function returns a constant reference to member data_float
 * @return Constant reference to member data_float
 */
const std::vector<DataExFloat>& DDSDataEx::data_float() const
{
    return m_data_float;
}

/*!
 * @brief This function returns a reference to member data_float
 * @return Reference to member data_float
 */
std::vector<DataExFloat>& DDSDataEx::data_float()
{
    return m_data_float;
}
/*!
 * @brief This function copies the value in member data_double
 * @param _data_double New value to be copied in member data_double
 */
void DDSDataEx::data_double(
        const std::vector<DataExDouble>& _data_double)
{
    m_data_double = _data_double;
}

/*!
 * @brief This function moves the value in member data_double
 * @param _data_double New value to be moved in member data_double
 */
void DDSDataEx::data_double(
        std::vector<DataExDouble>&& _data_double)
{
    m_data_double = std::move(_data_double);
}

/*!
 * @brief This function returns a constant reference to member data_double
 * @return Constant reference to member data_double
 */
const std::vector<DataExDouble>& DDSDataEx::data_double() const
{
    return m_data_double;
}

/*!
 * @brief This function returns a reference to member data_double
 * @return Reference to member data_double
 */
std::vector<DataExDouble>& DDSDataEx::data_double()
{
    return m_data_double;
}
/*!
 * @brief This function copies the value in member data_char
 * @param _data_char New value to be copied in member data_char
 */
void DDSDataEx::data_char(
        const std::vector<DataExChar>& _data_char)
{
    m_data_char = _data_char;
}

/*!
 * @brief This function moves the value in member data_char
 * @param _data_char New value to be moved in member data_char
 */
void DDSDataEx::data_char(
        std::vector<DataExChar>&& _data_char)
{
    m_data_char = std::move(_data_char);
}

/*!
 * @brief This function returns a constant reference to member data_char
 * @return Constant reference to member data_char
 */
const std::vector<DataExChar>& DDSDataEx::data_char() const
{
    return m_data_char;
}

/*!
 * @brief This function returns a reference to member data_char
 * @return Reference to member data_char
 */
std::vector<DataExChar>& DDSDataEx::data_char()
{
    return m_data_char;
}

size_t DDSDataEx::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;








    return current_align;
}

bool DDSDataEx::isKeyDefined()
{
    return false;
}

void DDSDataEx::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
         
}

Alarm::Alarm()
{
    // m_time_source com.eprosima.idl.parser.typecode.PrimitiveTypeCode@6f3b5d16
    m_time_source = 0;
    // m_value com.eprosima.idl.parser.typecode.PrimitiveTypeCode@78b1cc93
    m_value = 0;
    // m_quality com.eprosima.idl.parser.typecode.PrimitiveTypeCode@6646153
    m_quality = 0;

    // Just to register all known types
    registerTypeTopicsTypes();
}

Alarm::~Alarm()
{



}

Alarm::Alarm(
        const Alarm& x)
{
    m_time_source = x.m_time_source;
    m_value = x.m_value;
    m_quality = x.m_quality;
}

Alarm::Alarm(
        Alarm&& x)
{
    m_time_source = x.m_time_source;
    m_value = x.m_value;
    m_quality = x.m_quality;
}

Alarm& Alarm::operator =(
        const Alarm& x)
{

    m_time_source = x.m_time_source;
    m_value = x.m_value;
    m_quality = x.m_quality;

    return *this;
}

Alarm& Alarm::operator =(
        Alarm&& x)
{

    m_time_source = x.m_time_source;
    m_value = x.m_value;
    m_quality = x.m_quality;

    return *this;
}

size_t Alarm::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t Alarm::getCdrSerializedSize(
        const Alarm& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void Alarm::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_time_source;
    scdr << m_value;
    scdr << m_quality;

}

void Alarm::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_time_source;
    dcdr >> m_value;
    dcdr >> m_quality;
}

/*!
 * @brief This function sets a value in member time_source
 * @param _time_source New value for member time_source
 */
void Alarm::time_source(
        int64_t _time_source)
{
    m_time_source = _time_source;
}

/*!
 * @brief This function returns the value of member time_source
 * @return Value of member time_source
 */
int64_t Alarm::time_source() const
{
    return m_time_source;
}

/*!
 * @brief This function returns a reference to member time_source
 * @return Reference to member time_source
 */
int64_t& Alarm::time_source()
{
    return m_time_source;
}

/*!
 * @brief This function sets a value in member value
 * @param _value New value for member value
 */
void Alarm::value(
        char _value)
{
    m_value = _value;
}

/*!
 * @brief This function returns the value of member value
 * @return Value of member value
 */
char Alarm::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
char& Alarm::value()
{
    return m_value;
}

/*!
 * @brief This function sets a value in member quality
 * @param _quality New value for member quality
 */
void Alarm::quality(
        char _quality)
{
    m_quality = _quality;
}

/*!
 * @brief This function returns the value of member quality
 * @return Value of member quality
 */
char Alarm::quality() const
{
    return m_quality;
}

/*!
 * @brief This function returns a reference to member quality
 * @return Reference to member quality
 */
char& Alarm::quality()
{
    return m_quality;
}


size_t Alarm::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool Alarm::isKeyDefined()
{
    return false;
}

void Alarm::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
       
}

DDSAlarm::DDSAlarm()
{
    // m_time_source com.eprosima.idl.parser.typecode.PrimitiveTypeCode@21507a04
    m_time_source = 0;
    // m_time_service com.eprosima.idl.parser.typecode.PrimitiveTypeCode@143640d5
    m_time_service = 0;
    // m_alarms com.eprosima.idl.parser.typecode.SequenceTypeCode@6295d394

    // m_quality com.eprosima.idl.parser.typecode.SequenceTypeCode@475e586c


    // Just to register all known types
    registerTypeTopicsTypes();
}

DDSAlarm::~DDSAlarm()
{




}

DDSAlarm::DDSAlarm(
        const DDSAlarm& x)
{
    m_time_source = x.m_time_source;
    m_time_service = x.m_time_service;
    m_alarms = x.m_alarms;
    m_quality = x.m_quality;
}

DDSAlarm::DDSAlarm(
        DDSAlarm&& x)
{
    m_time_source = x.m_time_source;
    m_time_service = x.m_time_service;
    m_alarms = std::move(x.m_alarms);
    m_quality = std::move(x.m_quality);
}

DDSAlarm& DDSAlarm::operator =(
        const DDSAlarm& x)
{

    m_time_source = x.m_time_source;
    m_time_service = x.m_time_service;
    m_alarms = x.m_alarms;
    m_quality = x.m_quality;

    return *this;
}

DDSAlarm& DDSAlarm::operator =(
        DDSAlarm&& x)
{

    m_time_source = x.m_time_source;
    m_time_service = x.m_time_service;
    m_alarms = std::move(x.m_alarms);
    m_quality = std::move(x.m_quality);

    return *this;
}

size_t DDSAlarm::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (scada_ate::typetopics::GetMaxSizeDDSExVectorAlarms() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (scada_ate::typetopics::GetMaxSizeDDSExVectorAlarms() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);




    return current_alignment - initial_alignment;
}

size_t DDSAlarm::getCdrSerializedSize(
        const DDSAlarm& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.alarms().size() > 0)
    {
        current_alignment += (data.alarms().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.quality().size() > 0)
    {
        current_alignment += (data.quality().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }




    return current_alignment - initial_alignment;
}

void DDSAlarm::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_time_source;
    scdr << m_time_service;
    scdr << m_alarms;
    scdr << m_quality;

}

void DDSAlarm::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_time_source;
    dcdr >> m_time_service;
    dcdr >> m_alarms;
    dcdr >> m_quality;
}

/*!
 * @brief This function sets a value in member time_source
 * @param _time_source New value for member time_source
 */
void DDSAlarm::time_source(
        int64_t _time_source)
{
    m_time_source = _time_source;
}

/*!
 * @brief This function returns the value of member time_source
 * @return Value of member time_source
 */
int64_t DDSAlarm::time_source() const
{
    return m_time_source;
}

/*!
 * @brief This function returns a reference to member time_source
 * @return Reference to member time_source
 */
int64_t& DDSAlarm::time_source()
{
    return m_time_source;
}

/*!
 * @brief This function sets a value in member time_service
 * @param _time_service New value for member time_service
 */
void DDSAlarm::time_service(
        int64_t _time_service)
{
    m_time_service = _time_service;
}

/*!
 * @brief This function returns the value of member time_service
 * @return Value of member time_service
 */
int64_t DDSAlarm::time_service() const
{
    return m_time_service;
}

/*!
 * @brief This function returns a reference to member time_service
 * @return Reference to member time_service
 */
int64_t& DDSAlarm::time_service()
{
    return m_time_service;
}

/*!
 * @brief This function copies the value in member alarms
 * @param _alarms New value to be copied in member alarms
 */
void DDSAlarm::alarms(
        const std::vector<uint32_t>& _alarms)
{
    m_alarms = _alarms;
}

/*!
 * @brief This function moves the value in member alarms
 * @param _alarms New value to be moved in member alarms
 */
void DDSAlarm::alarms(
        std::vector<uint32_t>&& _alarms)
{
    m_alarms = std::move(_alarms);
}

/*!
 * @brief This function returns a constant reference to member alarms
 * @return Constant reference to member alarms
 */
const std::vector<uint32_t>& DDSAlarm::alarms() const
{
    return m_alarms;
}

/*!
 * @brief This function returns a reference to member alarms
 * @return Reference to member alarms
 */
std::vector<uint32_t>& DDSAlarm::alarms()
{
    return m_alarms;
}
/*!
 * @brief This function copies the value in member quality
 * @param _quality New value to be copied in member quality
 */
void DDSAlarm::quality(
        const std::vector<uint32_t>& _quality)
{
    m_quality = _quality;
}

/*!
 * @brief This function moves the value in member quality
 * @param _quality New value to be moved in member quality
 */
void DDSAlarm::quality(
        std::vector<uint32_t>&& _quality)
{
    m_quality = std::move(_quality);
}

/*!
 * @brief This function returns a constant reference to member quality
 * @return Constant reference to member quality
 */
const std::vector<uint32_t>& DDSAlarm::quality() const
{
    return m_quality;
}

/*!
 * @brief This function returns a reference to member quality
 * @return Reference to member quality
 */
std::vector<uint32_t>& DDSAlarm::quality()
{
    return m_quality;
}

size_t DDSAlarm::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;







    return current_align;
}

bool DDSAlarm::isKeyDefined()
{
    return false;
}

void DDSAlarm::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
        
}

DDSExAlarm::DDSExAlarm()
{
    // m_time_service com.eprosima.idl.parser.typecode.PrimitiveTypeCode@657c8ad9
    m_time_service = 0;
    // m_alarms com.eprosima.idl.parser.typecode.SequenceTypeCode@436a4e4b


    // Just to register all known types
    registerTypeTopicsTypes();
}

DDSExAlarm::~DDSExAlarm()
{


}

DDSExAlarm::DDSExAlarm(
        const DDSExAlarm& x)
{
    m_time_service = x.m_time_service;
    m_alarms = x.m_alarms;
}

DDSExAlarm::DDSExAlarm(
        DDSExAlarm&& x)
{
    m_time_service = x.m_time_service;
    m_alarms = std::move(x.m_alarms);
}

DDSExAlarm& DDSExAlarm::operator =(
        const DDSExAlarm& x)
{

    m_time_service = x.m_time_service;
    m_alarms = x.m_alarms;

    return *this;
}

DDSExAlarm& DDSExAlarm::operator =(
        DDSExAlarm&& x)
{

    m_time_service = x.m_time_service;
    m_alarms = std::move(x.m_alarms);

    return *this;
}

size_t DDSExAlarm::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += Alarm::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t DDSExAlarm::getCdrSerializedSize(
        const DDSExAlarm& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.alarms().size(); ++a)
    {
        current_alignment += Alarm::getCdrSerializedSize(data.alarms().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void DDSExAlarm::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_time_service;
    scdr << m_alarms;

}

void DDSExAlarm::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_time_service;
    dcdr >> m_alarms;
}

/*!
 * @brief This function sets a value in member time_service
 * @param _time_service New value for member time_service
 */
void DDSExAlarm::time_service(
        int64_t _time_service)
{
    m_time_service = _time_service;
}

/*!
 * @brief This function returns the value of member time_service
 * @return Value of member time_service
 */
int64_t DDSExAlarm::time_service() const
{
    return m_time_service;
}

/*!
 * @brief This function returns a reference to member time_service
 * @return Reference to member time_service
 */
int64_t& DDSExAlarm::time_service()
{
    return m_time_service;
}

/*!
 * @brief This function copies the value in member alarms
 * @param _alarms New value to be copied in member alarms
 */
void DDSExAlarm::alarms(
        const std::vector<Alarm>& _alarms)
{
    m_alarms = _alarms;
}

/*!
 * @brief This function moves the value in member alarms
 * @param _alarms New value to be moved in member alarms
 */
void DDSExAlarm::alarms(
        std::vector<Alarm>&& _alarms)
{
    m_alarms = std::move(_alarms);
}

/*!
 * @brief This function returns a constant reference to member alarms
 * @return Constant reference to member alarms
 */
const std::vector<Alarm>& DDSExAlarm::alarms() const
{
    return m_alarms;
}

/*!
 * @brief This function returns a reference to member alarms
 * @return Reference to member alarms
 */
std::vector<Alarm>& DDSExAlarm::alarms()
{
    return m_alarms;
}

size_t DDSExAlarm::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool DDSExAlarm::isKeyDefined()
{
    return false;
}

void DDSExAlarm::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}
